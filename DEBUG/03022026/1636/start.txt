# handlers/start.py
import re
from datetime import datetime
from aiogram import Router, F
from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from services.flight_search import search_flights, generate_booking_link, get_hot_offers, normalize_date
from utils.cities import CITY_TO_IATA, GLOBAL_HUBS, IATA_TO_CITY

router = Router()

def parse_passengers(s: str) -> str:
    if not s:
        return "1"
    if s.isdigit():
        return s
    adults = children = infants = 0
    for part in s.split(","):
        part = part.strip().lower()
        n = int(re.search(r"\d+", part).group()) if re.search(r"\d+", part) else 1
        if "–≤–∑—Ä" in part or "–≤–∑—Ä–æ—Å–ª" in part:
            adults = n
        elif "—Ä–µ–±" in part or "–¥–µ—Ç" in part:
            children = n
        elif "–º–ª" in part or "–º–ª–∞–¥" in part:
            infants = n
    return str(adults) + (str(children) if children else "") + (str(infants) if infants else "")

def build_passenger_desc(code: str):
    try:
        ad = int(code[0])
        ch = int(code[1]) if len(code) > 1 else 0
        inf = int(code[2]) if len(code) > 2 else 0
        parts = []
        if ad: parts.append(f"{ad} –≤–∑—Ä.")
        if ch: parts.append(f"{ch} —Ä–µ–±.")
        if inf: parts.append(f"{inf} –º–ª.")
        return parts or ["1 –≤–∑—Ä."]
    except:
        return ["1 –≤–∑—Ä."]

def format_user_date(date_str: str) -> str:
    """–ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç '–î–î.–ú–ú' ‚Üí '–î–î.–ú–ú.2026' –∏–ª–∏ '–î–î.–ú–ú.2027', –µ—Å–ª–∏ –¥–∞—Ç–∞ —É–∂–µ –ø—Ä–æ—à–ª–∞ (–Ω–∞ 03.02.2026)"""
    try:
        d, m = map(int, date_str.split('.'))
        year = 2026
        if m < 2 or (m == 2 and d < 3):
            year = 2027
        return f"{d:02d}.{m:02d}.{year}"
    except:
        return date_str

@router.message(F.text == "/start")
async def cmd_start(message: Message):
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚úàÔ∏è –¢–æ–ª—å–∫–æ —Ç—É–¥–∞", callback_data="type_oneway")],
        [InlineKeyboardButton(text="üîÅ –¢—É–¥–∞-–æ–±—Ä–∞—Ç–Ω–æ", callback_data="type_roundtrip")],
        [InlineKeyboardButton(text="üî• –ì–æ—Ä—è—á–∏–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è", callback_data="hot_offers")]
    ])
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –ø–æ–∏—Å–∫–∞:", reply_markup=kb)

@router.callback_query(F.data == "type_oneway")
async def handle_oneway(callback: CallbackQuery):
    await callback.answer()
    await callback.message.answer(
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∑–∞–ø—Ä–æ—Å –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
        "<code>–ì–æ—Ä–æ–¥ –≤—ã–ª–µ—Ç–∞ ‚Üí –ì–æ—Ä–æ–¥ –ø—Ä–∏–ª—ë—Ç–∞ –î–î.–ú–ú [–ø–∞—Å—Å–∞–∂–∏—Ä—ã]</code>\n\n"
        "–ü—Ä–∏–º–µ—Ä: <code>–ú–æ—Å–∫–≤–∞ ‚Üí –°–æ—á–∏ 10.03</code>",
        parse_mode="HTML"
    )

@router.callback_query(F.data == "type_roundtrip")
async def handle_roundtrip(callback: CallbackQuery):
    await callback.answer()
    await callback.message.answer(
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∑–∞–ø—Ä–æ—Å –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
        "<code>–ì–æ—Ä–æ–¥ –≤—ã–ª–µ—Ç–∞ ‚Üí –ì–æ—Ä–æ–¥ –ø—Ä–∏–ª—ë—Ç–∞ –î–î.–ú–ú ‚Äì –î–î.–ú–ú [–ø–∞—Å—Å–∞–∂–∏—Ä—ã]</code>\n\n"
        "–ü—Ä–∏–º–µ—Ä: <code>–ú–æ—Å–∫–≤–∞ ‚Üí –°–æ—á–∏ 10.03 ‚Äì 17.03</code>",
        parse_mode="HTML"
    )

@router.callback_query(F.data == "hot_offers")
async def handle_hot_offers(callback: CallbackQuery):
    await callback.answer()
    await callback.message.answer("–ò—â—É –≥–æ—Ä—è—á–∏–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è...")
    offers = await get_hot_offers(limit=7)
    if not offers:
        await callback.message.answer("–ù–µ—Ç –∞–∫—Ç—É–∞–ª—å–Ω—ã—Ö –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π üò¢")
        return

    text = "üî• –ì–æ—Ä—è—á–∏–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è:\n"
    keyboard = InlineKeyboardMarkup(inline_keyboard=[])
    for item in offers:
        origin = IATA_TO_CITY.get(item["origin"], item["origin"])
        dest = IATA_TO_CITY.get(item["destination"], item["destination"])
        price = item.get("value", "?")
        departure = item["departure_at"]
        # –í hot_offers ‚Äî –¥–∞—Ç–∞ –∏–∑ API, –Ω–æ –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º –∫–∞–∫ DD.MM
        try:
            dt = datetime.fromisoformat(departure.replace("Z", "+00:00"))
            dep_ddmm = f"{dt.day:02d}.{dt.month:02d}"
        except:
            dep_ddmm = departure[:10].replace("-", ".")[8:10] + "." + departure[:10].replace("-", ".")[5:7]
        text += f"‚Ä¢ {origin} ‚Üí {dest} ‚Äî –æ—Ç {price} ‚ÇΩ ‚Äî {dep_ddmm}\n"

        link = f"https://www.aviasales.ru/search/{item['origin']}{departure[5:7]}{departure[8:10]}{item['destination']}1"
        btn_text = f"‚úàÔ∏è {origin}‚Üí{dest} ({price} ‚ÇΩ)"
        keyboard.inline_keyboard.append([InlineKeyboardButton(text=btn_text, url=link)])

    await callback.message.answer(text)
    await callback.message.answer("–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–π—Å:", reply_markup=keyboard)

@router.message()
async def handle_flight_request(message: Message):
    text = message.text.strip().lower()

    round_match = re.search(
        r"([–∞-—è—ëa-z\s]+?)(?:\s*[-‚Üí>]\s*)([–∞-—è—ëa-z\s]+?)\s+(\d{1,2}\.\d{1,2})\s*[-‚Äì]\s*(\d{1,2}\.\d{1,2})\s*(.*)?",
        text, re.IGNORECASE
    )
    if round_match:
        origin_city, dest_city, depart_date, return_date, passengers_part = round_match.groups()
        is_roundtrip = True
    else:
        oneway_match = re.search(
            r"([–∞-—è—ëa-z\s]+?)(?:\s*[-‚Üí>]\s*)([–∞-—è—ëa-z\s]+?)\s+(\d{1,2}\.\d{1,2})\s*(.*)?",
            text, re.IGNORECASE
        )
        if not oneway_match:
            await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ù–∞–∂–º–∏—Ç–µ /start –∏ –≤—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –ø–æ–∏—Å–∫–∞.")
            return
        origin_city, dest_city, depart_date, passengers_part = oneway_match.groups()
        return_date = None
        is_roundtrip = False

    dest_iata = CITY_TO_IATA.get(dest_city)
    if not dest_iata:
        await message.answer(f"–ù–µ –∑–Ω–∞—é –≥–æ—Ä–æ–¥: {dest_city}")
        return

    passengers_code = parse_passengers((passengers_part or "").strip())
    passenger_desc = ", ".join(build_passenger_desc(passengers_code))

    if origin_city == "–≤–µ–∑–¥–µ":
        origins = GLOBAL_HUBS
    else:
        orig_iata = CITY_TO_IATA.get(origin_city)
        if not orig_iata:
            await message.answer(f"–ù–µ –∑–Ω–∞—é –≥–æ—Ä–æ–¥: {origin_city}")
            return
        origins = [orig_iata]

    # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–∞—Ç—ã –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è (–∫–∞–∫ –≤–≤—ë–ª –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å)
    display_depart = format_user_date(depart_date)
    display_return = format_user_date(return_date) if return_date else None

    await message.answer("–ò—â—É –±–∏–ª–µ—Ç—ã...")
    all_flights = []
    for orig in origins:
        flights = await search_flights(
            orig,
            dest_iata,
            normalize_date(depart_date),
            normalize_date(return_date) if return_date else None
        )
        for f in flights:
            f["origin"] = orig
        all_flights.extend(flights)

    if not all_flights:
        await message.answer("–ë–∏–ª–µ—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã üò¢")
        return

    all_flights.sort(key=lambda f: f.get("value") or f.get("price") or 999999)
    top_flights = all_flights[:3]

    response = f"‚úÖ –ù–∞–π–¥–µ–Ω–æ ({passenger_desc}):\n"
    for i, f in enumerate(top_flights, 1):
        price = f.get("value") or f.get("price") or "?"
        origin_name = IATA_TO_CITY.get(f["origin"], f["origin"])
        dest_name = IATA_TO_CITY.get(dest_iata, dest_iata)
        response += f'{i}. ‚úàÔ∏è {origin_name} ‚Üí {dest_name} ‚Äî –æ—Ç {price} ‚ÇΩ ‚Äî {display_depart}\n'
        if is_roundtrip and display_return:
            response += f'   ‚Ü©Ô∏è –û–±—Ä–∞—Ç–Ω–æ: {display_return}\n'

    await message.answer(response)

    keyboard = InlineKeyboardMarkup(inline_keyboard=[])
    for f in top_flights:
        price = f.get("value") or f.get("price") or "?"
        origin_name = IATA_TO_CITY.get(f["origin"], f["origin"])
        dest_name = IATA_TO_CITY.get(dest_iata, dest_iata)
        link = generate_booking_link(f, f["origin"], dest_iata, depart_date, passengers_code, return_date)
        if is_roundtrip:
            btn_text = f"‚úàÔ∏è –æ—Ç {price} ‚ÇΩ ‚Äî {origin_name}‚Üí{dest_name} ({display_depart} ‚Äì {display_return})"
        else:
            btn_text = f"‚úàÔ∏è –æ—Ç {price} ‚ÇΩ ‚Äî {origin_name}‚Üí{dest_name} ({display_depart})"
        keyboard.inline_keyboard.append([InlineKeyboardButton(text=btn_text, url=link)])

    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ:", reply_markup=keyboard)